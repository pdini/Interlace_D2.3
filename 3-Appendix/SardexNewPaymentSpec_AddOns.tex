\chapter*{Appendix: Additional Functional Requirements\\ and Business Logic Model (2018)}
\label{appendix}

\vspace{-1cm}
\begin{center}
Eduard Hirsch and Paolo Dini
\end{center}

In order to see how to manage a more challenging use case based on reading historic data placed on the chain, we model the ``delta-debt'' function as an additional requirement. This example could help foresee possible challenges for more complex tasks. The implementation details for the other requirements covered can be found in D3.2 \cite{INTERLACE_D32}.

\section{Requirement: Debt Record Tracking}

Sardex sets the credit line of the circuit's SME users based on their turnover as well as on their track record. Thus, the balance of an account, as described in the requirements specification deliverables D2.1 and D3.1 \cite{INTERLACE_D21,INTERLACE_D31}, can go negative (with a 0\% interest rate) up to a maximum amount that varies for each member company. It is a Sardex contractual requirement that such a negative amount or debt be ``paid back'' within 12 months of when it was incurred. The debt is not towards Sardex S.p.A. (Sardex S.p.A. is not a bank) and it is not bilateral towards a single other member. Rather, the debt is towards the circuit as a whole. Therefore, the indebted company can pay back or recover its debt simply by selling its products and services to any other members, at least for the amount of the debt and within 12 months of incurring it. In general, each and every transaction that increases the debt of an already negative balance needs to be recovered within a separate 12-month window.

More precisely, any transaction that increases the debt of an account triggers a recording of that newly created portion of debt and causes the system to allocate a separately handled due date 12 months later for its repayment. On the other hand, if an account receives a positive amount of credits (due to the sale of a product or service), then the ``debt-portions'' which that account may have accrued up to then are paid back in sequence, starting from the oldest unpaid one.

\renewcommand{\thefigure}{A.\arabic{figure}}
\setcounter{figure}{0}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\textwidth, clip, trim=1mm 1mm 1mm 1mm]{Figures/deltadebt}
  \caption{\bf\small The delta-debt progression}
  \label{fig:debt-graph}
\end{figure}

Figure \ref{fig:debt-graph} illustrates a transaction flow for a single account with 5 transactions and their timestamps named $t_i$, where $i$ covers the interval $[-2,2]$ in discrete steps of $1$. Two timestamps $t_j$ and $t_k$ having a $j>k$ imply that $t_j$ is older than $t_k$. Let's assume a transaction at $t_0$, as illustrated in the figure, which turns a positive balance into a negative value. That event then defines a starting timestamp at $t_0$. This transaction at $t_0$ creates a debt whose value is recorded in the variable $balance$ reduced by the transaction $amount$ given that $balance \ge 0$ and $amount > balance$. Debt will be handled further as a positive value, thus, we define a debt at position $i$

\begin{asm}
	debt_{t_i} = \left\{\begin{array}{ll}
           |balance_{t_i} - amount_{t_i}| \+\+ & \IF i = 0 \AND balance_{t_0} \ge 0 \AND amount > balance\\
           amount_{t_i} & \ELSEIF i > 0 \AND balance_{t_i} < 0\\
           \UNDEF & \ELSE
        \end{array}\right .\-
\end{asm}

By declaring $TXID_i$ as the transaction id which is executed at time $t_i$ and $MBRID$ as the member id, we are defining a so-called \textit{deltaDebt} as the following tuple:

\begin{asm}
	dD_i = (t_i, TXID_i, Amount_{t_i}, DebtPos_{t_i}, MBRID)
\end{asm}

where $Amount_{t_i}$ and $DebtPos_{t_i}$ are initialized with $debt_{t_i}$. In the following, $Amount_{t_i}$ will always stay with its original value whereas $DebtPos_{t_i}$ is reduced by any amount \textbf{received} by the same account.

The creation of a \textit{deltaDebt} can be described as follows:

\begin{asm}
	\ASM{CreateDeltaDebt}(txid,currentDate,from,to,amount)=\+
		\LET balance = \ASM{balanceOf}(from)\+
			\IF (balance - amount) < 0 \THEN\+
				\LET debt =  \+\left\{\begin{array}{ll}
						|balance - amount|\+& \IF balance > 0\\
						amount & \ELSE
					\end{array}\right.\-\-
				\LET deltaDebt = (currentDate, txid, debt, debt, from)\+
					\ASM{WriteDeltaDebt}(deltaDebt)
\end{asm}

In order to pay back an open debt, at every transfer \st{it} \textcolor{blue}{the balance} needs to be checked for possible debt clearances:

\begin{asm}
	\ASM{ClearDeltaDebt}(txid,credit,channel,to,amount)=\+
		\LET openDeltas = \ASM{SelectOpenDeltaDebtsFor}(to)\+
			\ASM{ClearDebt}(openDeltas, amount)\dec\-
	\WHERE \+
		\ASM{ClearDebt}(openDeltas, amount) =\+
		\LET delta = \ASM{SelectMinDelta}(openDeltas)\+
			\IF debtPos(delta) \ge amount \THEN\+
				debtPos(delta) := debtPos(delta) - amount\-
			\ELSE\+
				\LET restAmount = amount - debtPos(delta)\+
					debtPos(delta) := 0\SEQ\\
					\ASM{ClearDebt}(openDeltas, restAmount )\dec\dec\dec\-
%		\ASM{SelectMinDelta}(openDeltas)\+
%			\FORALL delta \IN openDeltas \WITH debtPos(delta) > 0 \DO\+
%				\IF min(delta) =\ \UNDEF\ \OR  min(delta) > timestamp(delta) \THEN\+
%					min(delta) = timestamp(delta)\dec\-
%			return\ min(delta)
\end{asm}


In this ASM example we assume that \ASM{SelectOpenDeltaDebtsFor} is returning a list of open \textit{deltaDebt} entries from the persistence layer with $debtPos(delta)>0$. \ASM{SelectMinDelta} selects the delta-debt of a corresponding list that has the minimum timestamp given that all cleared debts having $debtPos(delta) = 0$ are excluded.

$debtPos(delta)$ reads or writes the pending amount for a particular debt (here: $delta$).









