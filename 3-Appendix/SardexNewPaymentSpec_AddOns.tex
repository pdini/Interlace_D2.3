\chapter*{Appendix: Additional Functional Requirements\\ and Business Logic Model (2018)}
\label{appendix}

\vspace{-1cm}
\begin{center}
Eduard Hirsch and Paolo Dini
\end{center}

In order to see how to manage a more challenging use case based on reading historic data placed on the chain, we modelled the ``delta-debt'' function as a additional requirement. This example could help forsee possible challenges for more complex tasks. The implementation details for the other requirements covered may be found in \cite{INTERLACE_D32}.

\section{Requirement: Debt Record Tracking}

Sardex sets the credit line of the circuit's SME users based on their turnover as well as on their track record. Thus, the balance of an account, as described in the requirements of \cite{INTERLACE_D21} as well as \cite{INTERLACE_D31}, can go negative (with a 0\% interest rate). That negative amount or debt needs to be paid back within 12 Month from the time of the transaction that made the balance negative and, more generally, from the time of any transaction that increases the debt of an already negative balance.

More precisely, any transaction that increases the debt of an account triggers a recording of that newly created portion of debt and causes the system to allocate a separately-handled due date 12 months later for its repayment. On the other hand, if an account receives a positive amount of credits (due to the sale of a product or service), then the ``debt-portions'' which that account may have accrued up to then are paid back in sequence, starting from the oldest unpaid one.

\renewcommand{\thefigure}{A.\arabic{figure}}
\setcounter{figure}{0}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7\textwidth, clip, trim=1mm 1mm 1mm 1mm]{Figures/deltadebt}
  \caption{\bf\small The delta-debt progression}
  \label{fig:debt-graph}
\end{figure}

Figure \ref{fig:debt-graph} illustrates a transaction flow for a single account with 5 transactions and their timestamps named $t_i$, where $i$ covers the interval $[-2,2]$ in discrete steps of $1$. Two timestamps $t_j$ and $t_k$ with $j>k$ imply that $t_j$ is older than $t_k$. Let's assume a transaction, as illustrated in the figure, which turns a positive balance into a negative value. That event then defines a starting timestamp at $t_0$.

The transaction at $t_0$ creates a debt whose value is stored in the variable $balance$ after the transaction. In other words, the value of $balance$ before the transaction is reduced by the transaction $amount$, and it becomes a debt because, before the transaction, $balance \ge 0$ and $amount > balance$. The debts $debt_{t_0}$ and $debt_{t_1}$ created by this transaction and by a possible further transaction, respectively, are represented in Figure \ref{fig:debt-graph}. Furthermore, these debts are treated as positive values. Thus, we define a debt created at $t_i$ as

\vspace{0.2cm}
\begin{asm}
	debt_{t_i} = \left\{\begin{array}{ll}
           |balance_{t_i} - amount_{t_i}| \+\+ & \IF i = 0 \AND balance_{t_0} \ge 0 \AND amount > balance\\
           amount_{t_i} & \ELSEIF i > 0 \AND balance_{t_i} < 0\\
           0 & \ELSE
        \end{array}\right.
\end{asm}
\vspace{-0.2cm}

When declaring $txid_{t_i}$ as the id for a transaction which is executed at time $t_i$ and $accid$ as the account id, we are defining a so-called \textit{deltaDebt} with index $i$ as the following tuple:
\begin{align}
	deltaDebt_i = (t_i, txid_{t_i}, amount_{t_i}, debtPos_{t_i}, accid),
\end{align}
where the $amount_{t_i}$ as well as $debtPos_{t_i}$ are both initialized with $debt_{t_i}$. In the following, $amount_{t_i}$ will always remain at its original value whereas $debtPos_{t_i}$ will be reduced by an amount \textbf{received} by the corresponding account.

The creation of a \textit{deltaDebt} can be described as follows:

\begin{asm}
	\ASM{CreateDeltaDebt}(txid,currentDate,from,amount)=\+
		\LET balance = \ASM{balanceOf}(from)\+
			\IF (balance - amount) < 0 \THEN\+
				\LET debt =  \+\left\{\begin{array}{ll}
						|balance - amount|\+& \IF balance > 0\\
						amount & \ELSE
					\end{array}\right.\-\-
				\LET deltaDebt = (currentDate, txid, debt, debt, from)\+
					\ASM{WriteDeltaDebt}(deltaDebt)
\end{asm}

In order to pay back an open debt, at every transfer the $deltaDebt$s need to be checked for possible clearances:

\begin{asm}
	\ASM{ClearDeltaDebt}(txid,to,amount)=\+
		\LET openDeltas = \ASM{SelectOpenDeltaDebtsFor}(to)\+
			\ASM{ClearDebt}(openDeltas, amount)\dec\-
	\WHERE \+
		\ASM{ClearDebt}(openDeltas, amount) =\+
		\IF amount > 0 \THEN\+
			\LET Tmin = \ASM{SelectOldestDebt}(openDeltas)\\
			\IF (Tmin\ \neq\ \UNDEF) \THEN\+
				\IF debtPos(Tmin) \ge amount \THEN\+
					debtPos(Tmin) := debtPos(Tmin) - amount\-
				\ELSE\+
					\LET restAmount = amount - debtPos(Tmin)\+
						debtPos(Tmin) := 0\\
						\ASM{ClearDebt}(\{d \in openDeltas\ |\ d \neq Tmin \}, restAmount )\dec\dec\dec\-
\end{asm}


In this ASM example we assume that \ASM{SelectOpenDeltaDebtsFor} is returning a list of open \textit{deltaDebt} entries from the persistence layer where $debtPos$ of each $deltaDebt$ is bigger than $0$. \ASM{SelectOldestDebt} selects the $deltaDebt$ of a corresponding list with a minimum timestamp. Further \ASM{SelectOldestDebt} returns \textbf{undef} if $openDeltas$ are empty or also \textbf{undef}.

$debtPos(Tmin)$ reads or writes the pending amount for a particular $deltaDebt$ (here: $Tmin$).









